<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comunicador Ocular de Acessibilidade</title>
    <!-- Carrega Tailwind CSS para estilização fácil e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #f7f9fc;
        }
        #keyboard-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
        }
        #keyboard-grid-container {
            max-height: 40vh;
            overflow-y: auto;
        }
        .key-button {
            padding: 0.75rem 0.5rem;
            text-align: center;
            font-size: 1.125rem;
            font-weight: 600;
            background-color: #ffffff;
            color: #1f2937;
            border: 2px solid #e5e7eb;
            transition: all 0.1s;
            cursor: default; /* Remove cursor interaction hint */
            user-select: none;
            border-radius: 0.5rem;
        }
        .key-button:hover {
            border-color: #d1d5db;
        }
        .highlighted {
            background-color: #3b82f6; /* Azul Primário */
            color: white;
            border-color: #2563eb;
            box-shadow: 0 4px 6px rgba(59, 130, 246, 0.5);
            transform: scale(1.05);
        }
        .progress-bar {
            height: 8px;
            background-color: #111827;
            width: 0%;
            transition: width 0.1s linear;
            position: absolute;
            bottom: 0;
            left: 0;
            border-radius: 0 0 0.5rem 0.5rem;
        }
        .key-container {
            position: relative;
            overflow: hidden;
        }
        #video-container {
            position: relative;
            width: 320px;
            height: 240px;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }
        #webcam-video, #webcam-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Espelha a imagem */
        }
        #gaze-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9998;
        }
        #gaze-dot {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2563eb;
            box-shadow: 0 0 0 8px rgba(37,99,235,0.25);
            transform: translate(-100px,-100px);
        }
        #keyboard-grid-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9990;
            padding: 2rem;
            background: #ffffff;
        }
        #keyboard-grid-container.fullscreen #keyboard-grid {
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
        }
        #keyboard-grid-container.fullscreen .key-button {
            padding: 1.5rem;
            font-size: 2rem;
            border-width: 3px;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="gaze-overlay"><div id="gaze-dot"></div></div>

    <header class="text-center mb-6">
        <h1 class="text-3xl font-bold text-gray-800">Comunicador Ocular (Simulação)</h1>
        <p class="text-gray-500">Comunicação por permanência de olhar (Dwell Time) - 5 segundos para seleção.</p>
    </header>

    <main class="flex flex-col lg:flex-row gap-8 flex-1">
        
        <!-- Painel de Controle e Vídeo -->
        <div class="lg:w-1/3 flex flex-col items-center">
            
            <div id="video-container" class="mb-6">
                <video id="webcam-video" autoplay playsinline></video>
                <canvas id="webcam-canvas"></canvas>
            </div>

            <div class="p-4 bg-white rounded-xl shadow-lg w-full max-w-sm">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">Status e Calibração</h2>
                
                <p id="status-message" role="status" aria-live="polite" class="text-sm mb-4 text-red-500 font-medium">Aguardando inicialização da câmera...</p>
                
                <button id="calibrate-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg shadow transition duration-150" disabled>
                    1. Calibrar Olhar
                </button>
                <p class="text-sm text-gray-600 mt-2">Clique para iniciar e siga o ponto nos cantos e centro.</p>

                <div class="mt-4">
                    <label for="dwell-slider" class="block text-sm font-medium text-gray-700">Tempo de permanência (segundos): <span id="dwell-value" class="font-bold">5</span></label>
                    <input id="dwell-slider" type="range" min="1" max="6" step="1" value="5" class="w-full mt-1">
                </div>

                <div class="mt-4 p-3 bg-gray-100 rounded-md">
                    <p class="text-sm font-medium text-gray-600">Posição da Cabeça (X, Y):</p>
                    <p id="head-position" class="text-lg font-mono text-gray-800">0, 0</p>
                </div>
            </div>
        </div>

        <!-- Teclado e Saída de Texto -->
        <div class="lg:w-2/3 flex flex-col">
            <h2 class="text-2xl font-semibold mb-3 text-gray-700">Saída de Texto</h2>
            <div class="flex-1 mb-6 p-4 bg-white rounded-xl shadow-lg border border-gray-200">
                <textarea id="text-output" aria-label="Saída de texto" rows="5" class="w-full text-xl p-2 focus:outline-none resize-none" placeholder="O texto selecionado aparecerá aqui..."></textarea>
                <div class="flex justify-end space-x-2 mt-2">
                    <button id="delete-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-1 px-3 rounded-lg text-sm transition">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 inline-block mr-1">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M12 9.75v6m0 0l-3-3m3 3l3-3m-8.25 4.5h-2.25a2.25 2.25 0 01-2.25-2.25V5.25A2.25 2.25 0 014.5 3h15.75c1.24 0 2.25 1.01 2.25 2.25v13.5A2.25 2.25 0 0120.25 21H16.5" />
                        </svg>
                        Apagar Último
                    </button>
                    <button id="clear-btn" class="bg-red-500 hover:bg-red-600 text-white font-medium py-1 px-3 rounded-lg text-sm transition">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 inline-block mr-1">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.122 1.02.215v3.12c0 1.25-.97 2.25-2.25 2.25H9c-1.25 0-2.25-.97-2.25-2.25V6.026a2.26 2.26 0 011.02-.215m10.8-2.673c-.112-.37-.417-.674-.788-.788-1.5-.47-3.085-.71-4.717-.71-1.63 0-3.217.24-4.717.71-.37.114-.675.418-.787.788-1.5.47-3.085.71-4.717.71-1.63 0-3.217.24-4.717.71L12 21.75l2.42-7.26c.214-.64.84-1.12 1.543-1.12h4.51c.703 0 1.33.48 1.543 1.12L21 21.75l2.42-7.26c.214-.64.84-1.12 1.543-1.12H27c.703 0 1.33.48 1.543 1.12L30 21.75" />
                        </svg>
                        Limpar Tudo
                    </button>
                </div>
            </div>

            <h2 class="text-2xl font-semibold mb-3 text-gray-700">Teclado Virtual</h2>
            <div id="keyboard-grid-container" class="bg-white p-6 rounded-xl shadow-2xl flex-1">
                <div id="keyboard-grid" role="grid">
                    <!-- Botões serão inseridos aqui pelo JavaScript -->
                </div>
            </div>
        </div>

    </main>

    <!-- Scripts da Biblioteca clmtrackr e Modelo -->
    <script src="https://cdn.jsdelivr.net/npm/clmtrackr@1.1.2/build/clmtrackr.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/clmtrackr@1.1.2/models/model_pca_20_svm.js"></script>
    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>

    <script>
        // --- VARIÁVEIS GLOBAIS ---
        const video = document.getElementById('webcam-video');
        const canvas = document.getElementById('webcam-canvas');
        const context = canvas.getContext('2d');
        const tracker = new clm.tracker();
        
        const statusMessage = document.getElementById('status-message');
        const headPositionDisplay = document.getElementById('head-position');
        const calibrateBtn = document.getElementById('calibrate-btn');
        const textOutput = document.getElementById('text-output');
        const keyboardGrid = document.getElementById('keyboard-grid');
        const keyboardGridContainer = document.getElementById('keyboard-grid-container');
        const deleteBtn = document.getElementById('delete-btn');
        const clearBtn = document.getElementById('clear-btn');
        let lastGaze = null;
        let deviceMoving = false;
        let lastMotionTime = 0;
        const MOTION_COOLDOWN_MS = 500;
        let calibrating = false;
        
        // Posição de calibração (centro neutro)
        let neutralX = 0;
        let neutralY = 0;
        let isCalibrated = false;
        let gazeTransform = null;
        let lastSmoothed = null;
        const SMOOTH_ALPHA = 0.3;
        let gazePoly = null;
        const KEY_SWITCH_HYSTERESIS_MS = 150;
        let pendingKey = null;
        let pendingSince = 0;

        // Parâmetros de Seleção
        let DWELL_TIME_SECONDS = 5;
        const SELECTION_INTERVAL_MS = 100;
        let currentSelectionKey = null; // O botão atualmente destacado
        let selectionProgress = 0; // Contagem de progresso (em intervalos)
        let MAX_PROGRESS = DWELL_TIME_SECONDS * (1000 / SELECTION_INTERVAL_MS);

        // --- TECLADO VIRTUAL ---
        // Adicionando um array de chaves para o teclado
        const keys = [
            'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
            'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ' ', // Espaço no final
            'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '!',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
            '?', '@', '#', '$', '%', '&', '*', '+', '-', '<' // Símbolos diversos
        ];

        // --- FUNÇÕES DE SETUP ---

        /**
         * Inicializa o stream da webcam e o tracker.
         */
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                
                // Espera o vídeo carregar para definir as dimensões do canvas
                video.onloadedmetadata = () => {
                    const videoWidth = video.videoWidth;
                    const videoHeight = video.videoHeight;

                    // Defina as dimensões do vídeo e do canvas
                    video.width = videoWidth;
                    video.height = videoHeight;
                    canvas.width = videoWidth;
                    canvas.height = videoHeight;

                    // Inicializa o rastreador (clmtrackr)
                    tracker.init(pModel);
                    tracker.start(video);
                    
                    statusMessage.textContent = 'Câmera e Rastreamento de Face Ativos.';
                    statusMessage.classList.remove('text-red-500');
                    statusMessage.classList.add('text-blue-500');
                    calibrateBtn.disabled = false;
                    
                    // Inicia o loop principal
                    requestAnimationFrame(drawLoop);
                };

            } catch (err) {
                console.error("Erro ao acessar a webcam:", err);
                statusMessage.textContent = 'ERRO: Não foi possível acessar a câmera. Verifique as permissões.';
                statusMessage.classList.remove('text-red-500');
                statusMessage.classList.add('text-white', 'bg-red-700', 'p-2', 'rounded');
            }
        }

        /**
         * Cria e insere os botões do teclado no DOM.
         */
        function createKeyboard() {
            keys.forEach(key => {
                const container = document.createElement('div');
                container.className = 'key-container';
                container.setAttribute('data-key', key);

                const button = document.createElement('button');
                button.className = 'key-button w-full h-full';
                button.textContent = key === ' ' ? 'ESPAÇO' : key;
                button.id = `key-${key.replace(/[^a-zA-Z0-9]/g, 'symbol')}`; // ID seguro
                button.setAttribute('role','button');
                button.setAttribute('aria-label', key === ' ' ? 'Espaço' : key);

                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                progressBar.style.width = '0%';
                
                container.appendChild(button);
                container.appendChild(progressBar);
                keyboardGrid.appendChild(container);
            });
        }
        
        // --- FUNÇÕES DE RASTREAMENTO E MAPEAMENTO ---

        /**
         * Loop principal de desenho e rastreamento.
         */
        function drawLoop() {
            requestAnimationFrame(drawLoop);
            
            context.clearRect(0, 0, canvas.width, canvas.height);
        }

        /**
         * Define a posição atual da cabeça como o centro neutro.
         */
        function calibrate() {
            const positions = tracker.getCurrentPosition();
            if (positions && positions[33]) {
                const headCenter = positions[33];
                neutralX = headCenter[0] / video.width;
                neutralY = headCenter[1] / video.height;
                isCalibrated = true;
                
                statusMessage.textContent = `CALIBRADO! Posição Neutra: ${neutralX.toFixed(2)}, ${neutralY.toFixed(2)}.`;
                statusMessage.classList.remove('text-blue-500', 'text-red-500');
                statusMessage.classList.add('text-green-500');
                calibrateBtn.textContent = 'RECALIBRAR';
            } else {
                statusMessage.textContent = 'Erro de Calibração: Rosto não detectado. Tente novamente.';
                statusMessage.classList.remove('text-green-500');
                statusMessage.classList.add('text-red-500');
            }
        }

        /**
         * Processa a posição simulada do olhar e atualiza a interface.
         * @param {number} x Posição X simulada (e.g., 0 a 1000)
         * @param {number} y Posição Y simulada (e.g., 0 a 1000)
         */
        function processGaze(x, y) {
            const gridRect = keyboardGrid.getBoundingClientRect();
            
            // Converte a posição simulada (0-1000) para coordenadas de tela
            const screenX = gridRect.left + (x / 1000) * gridRect.width;
            const screenY = gridRect.top + (y / 1000) * gridRect.height;
            
            // Encontra o elemento (botão) que corresponde à posição
            const elements = document.elementsFromPoint(screenX, screenY);
            
            let targetKeyContainer = elements.find(el => el.classList.contains('key-container'));
            
            // Se o elemento estiver fora do grid, tente encontrar o grid container
            if (!targetKeyContainer) {
                 targetKeyContainer = elements.find(el => el.id === 'keyboard-grid-container');
            }

            // Garante que o elemento seja um container de chave
            if (targetKeyContainer && targetKeyContainer.getAttribute('data-key')) {
                highlightKey(targetKeyContainer);
            } else {
                // Se não estiver olhando para nenhuma chave válida
                resetSelection();
            }
        }

        function processGazeScreenPoint(x, y) {
            let tx = x;
            let ty = y;
            if (gazePoly) {
                const xx = x; const yy = y;
                tx = gazePoly.ax[0] + gazePoly.ax[1]*xx + gazePoly.ax[2]*yy + gazePoly.ax[3]*xx*xx + gazePoly.ax[4]*xx*yy + gazePoly.ax[5]*yy*yy;
                ty = gazePoly.ay[0] + gazePoly.ay[1]*xx + gazePoly.ay[2]*yy + gazePoly.ay[3]*xx*xx + gazePoly.ay[4]*xx*yy + gazePoly.ay[5]*yy*yy;
            } else if (gazeTransform) {
                tx = gazeTransform[0] * x + gazeTransform[1] * y + gazeTransform[2];
                ty = gazeTransform[3] * x + gazeTransform[4] * y + gazeTransform[5];
            }
            tx += (window.driftOffset && window.driftOffset.x) || 0;
            ty += (window.driftOffset && window.driftOffset.y) || 0;
            if (lastSmoothed) {
                tx = SMOOTH_ALPHA * tx + (1 - SMOOTH_ALPHA) * lastSmoothed.x;
                ty = SMOOTH_ALPHA * ty + (1 - SMOOTH_ALPHA) * lastSmoothed.y;
            }
            lastSmoothed = { x: tx, y: ty };
            tx = Math.max(0, Math.min(window.innerWidth - 1, tx));
            ty = Math.max(0, Math.min(window.innerHeight - 1, ty));
            const gazeDot = document.getElementById('gaze-dot');
            if (gazeDot) {
                gazeDot.style.transform = `translate(${tx - 10}px, ${ty - 10}px)`;
            }
            if (calibrating) return;
            const targetKeyContainer = nearestKeyContainerAt(tx, ty);
            if (targetKeyContainer && targetKeyContainer.getAttribute('data-key')) {
                if (currentSelectionKey !== targetKeyContainer) {
                    if (pendingKey !== targetKeyContainer) {
                        pendingKey = targetKeyContainer;
                        pendingSince = Date.now();
                    } else if (Date.now() - pendingSince >= KEY_SWITCH_HYSTERESIS_MS) {
                        highlightKey(targetKeyContainer);
                        pendingKey = null;
                        pendingSince = 0;
                    }
                } else {
                    highlightKey(targetKeyContainer);
                    pendingKey = null;
                    pendingSince = 0;
                }
            } else {
                resetSelection();
                pendingKey = null;
                pendingSince = 0;
            }
        }
        
        // --- FUNÇÕES DE SELEÇÃO POR PERMANÊNCIA (DWELL) ---

        /**
         * Destaca uma chave e inicia/continua o progresso de seleção.
         * @param {HTMLElement} keyContainer O container da chave para destacar.
         */
        function highlightKey(keyContainer) {
            if (currentSelectionKey !== keyContainer) {
                // Se mudou para uma nova chave, reseta a anterior e começa a nova
                resetSelection();
                currentSelectionKey = keyContainer;
                selectionProgress = 0;
            }

            // Adiciona a classe de destaque visual
            const button = keyContainer.querySelector('.key-button');
            const progressBar = keyContainer.querySelector('.progress-bar');
            
            if (!button.classList.contains('highlighted')) {
                button.classList.add('highlighted');
            }

            // Atualiza o progresso visual
            const percentage = (selectionProgress / MAX_PROGRESS) * 100;
            progressBar.style.width = `${percentage}%`;
        }

        /**
         * Reseta o estado de seleção para todas as chaves.
         */
        function resetSelection() {
            if (currentSelectionKey) {
                // Remove destaque e zera a barra de progresso da chave anterior
                currentSelectionKey.querySelector('.key-button').classList.remove('highlighted');
                currentSelectionKey.querySelector('.progress-bar').style.width = '0%';
            }
            currentSelectionKey = null;
            selectionProgress = 0;
        }

        /**
         * Loop que checa e processa o tempo de permanência.
         */
        function selectionLoop() {
            if (!isCalibrated) return;
            if (!deviceMoving && currentSelectionKey && !calibrating) {
                selectionProgress++;

                const keyChar = currentSelectionKey.getAttribute('data-key');
                const button = currentSelectionKey.querySelector('.key-button');
                const progressBar = currentSelectionKey.querySelector('.progress-bar');

                // Atualiza o progresso visual
                const percentage = (selectionProgress / MAX_PROGRESS) * 100;
                progressBar.style.width = `${percentage}%`;

                if (selectionProgress >= MAX_PROGRESS) {
                    // SELEÇÃO CONCLUÍDA!
                    
                    let currentText = textOutput.value;
                    if (keyChar === ' ') {
                        textOutput.value = currentText + ' ';
                    } else if (keyChar === '<') {
                        // Simulação de Backspace/Apagar último
                        textOutput.value = currentText.slice(0, -1);
                    } else {
                         textOutput.value = currentText + keyChar;
                    }

                    // Efeito visual de seleção
                    button.classList.remove('highlighted');
                    button.classList.add('bg-purple-500', 'scale-110');
                    setTimeout(() => {
                        button.classList.remove('bg-purple-500', 'scale-110');
                        button.classList.add('highlighted');
                    }, 100);

                    const rect = currentSelectionKey.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    if (!window.driftOffset) window.driftOffset = { x: 0, y: 0 };
                    const last = lastSmoothed || { x: cx, y: cy };
                    const dx = cx - last.x;
                    const dy = cy - last.y;
                    const DRIFT_ALPHA = 0.05;
                    window.driftOffset.x = window.driftOffset.x * (1 - DRIFT_ALPHA) + dx * DRIFT_ALPHA;
                    window.driftOffset.y = window.driftOffset.y * (1 - DRIFT_ALPHA) + dy * DRIFT_ALPHA;

                    if (window.selectionBeep) window.selectionBeep();

                    // Reinicia a seleção para a chave atual (para que o olhar fixo possa selecionar novamente imediatamente)
                    selectionProgress = 0;
                }
            }
        }

        function nearestKeyContainerAt(x, y) {
            const rect = keyboardGridContainer.getBoundingClientRect();
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return null;
            const nodes = keyboardGrid.querySelectorAll('.key-container');
            let best = null; let bestd2 = Infinity;
            for (let i = 0; i < nodes.length; i++) {
                const r = nodes[i].getBoundingClientRect();
                const cx = r.left + r.width / 2;
                const cy = r.top + r.height / 2;
                const dx = cx - x; const dy = cy - y; const d2 = dx*dx + dy*dy;
                if (d2 < bestd2) { bestd2 = d2; best = nodes[i]; }
            }
            return best;
        }
        
        // --- EVENT LISTENERS E INICIALIZAÇÃO ---

        // Configura o teclado, câmera e eventos ao carregar
        window.onload = function() {
            createKeyboard();
            setupCamera();
            keyboardGridContainer.style.display = 'none';
            textOutput.disabled = true;
            deleteBtn.disabled = true;
            clearBtn.disabled = true;
            
            calibrateBtn.addEventListener('click', startGazeCalibration);

            const dwellSlider = document.getElementById('dwell-slider');
            const dwellValue = document.getElementById('dwell-value');
            dwellSlider.addEventListener('input', () => {
                DWELL_TIME_SECONDS = parseInt(dwellSlider.value, 10);
                dwellValue.textContent = String(DWELL_TIME_SECONDS);
                MAX_PROGRESS = DWELL_TIME_SECONDS * (1000 / SELECTION_INTERVAL_MS);
                selectionProgress = 0;
            });

            // Adiciona funcionalidade aos botões de controle de texto
            deleteBtn.addEventListener('click', () => {
                let currentText = textOutput.value;
                textOutput.value = currentText.slice(0, -1);
            });
            clearBtn.addEventListener('click', () => {
                textOutput.value = '';
            });

            // Inicia o loop de seleção por intervalo
            setInterval(selectionLoop, SELECTION_INTERVAL_MS);

            ensureWebGazer().then(() => {
                if (window.webgazer) {
                    webgazer.applyKalmanFilter(true);
                    webgazer.setRegression('ridge');
                    webgazer.setTracker('TFFacemesh');
                    webgazer.showVideo(false);
                    webgazer.showFaceOverlay(false);
                    webgazer.showFaceFeedbackBox(false);
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (AC) {
                        const ctx = new AC();
                        window.selectionBeep = () => {
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();
                            osc.type = 'sine';
                            osc.frequency.value = 880;
                            osc.connect(gain);
                            gain.connect(ctx.destination);
                            gain.gain.setValueAtTime(0.001, ctx.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.25, ctx.currentTime + 0.01);
                            osc.start();
                            osc.stop(ctx.currentTime + 0.12);
                        };
                    }
                    webgazer.setGazeListener(function(data){
                        if (data && typeof data.x === 'number' && typeof data.y === 'number') {
                            if (calibrating) {
                                updateCalibrationCursor(data.x, data.y);
                            } else if (isCalibrated) {
                                processGazeScreenPoint(data.x, data.y);
                            }
                        }
                    }).begin();
                    webgazer.saveDataAcrossSessions(true);
                    statusMessage.textContent = 'Rastreamento ocular pronto. Inicie a calibração do olhar.';
                    statusMessage.classList.remove('text-red-500');
                    statusMessage.classList.add('text-blue-500');
                    calibrateBtn.disabled = false;
                } else {
                    statusMessage.textContent = 'Falha ao carregar rastreamento ocular. Tente recarregar.';
                    statusMessage.classList.add('text-red-500');
                }
            });

            window.addEventListener('devicemotion', (e) => {
                const a = e.accelerationIncludingGravity || {};
                const ax = Math.abs(a.x || 0);
                const ay = Math.abs(a.y || 0);
                const az = Math.abs(a.z || 0);
                const threshold = 1.5;
                const moving = (ax + ay + az) > threshold;
                if (moving) {
                    deviceMoving = true;
                    lastMotionTime = Date.now();
                } else {
                    if (Date.now() - lastMotionTime > MOTION_COOLDOWN_MS) {
                        deviceMoving = false;
                    }
                }
            });
        };

        function ensureWebGazer() {
            return new Promise((resolve) => {
                if (window.webgazer) return resolve();
                const s = document.createElement('script');
                s.src = 'https://webgazer.cs.brown.edu/webgazer.js';
                s.async = true;
                s.onload = () => resolve();
                s.onerror = () => resolve();
                document.head.appendChild(s);
            });
        }

        async function startGazeCalibration() {
            if (!window.webgazer) return;
            calibrating = true;
            selectionProgress = 0;
            resetSelection();
            calibrateBtn.disabled = true;
            calibrateBtn.textContent = 'Calibrando...';
            const overlay = document.createElement('div');
            overlay.id = 'calibration-overlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.background = 'rgba(0,0,0,0.35)';
            overlay.style.zIndex = '9999';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.pointerEvents = 'none';

            const instruction = document.createElement('div');
            instruction.textContent = 'Siga o ponto com os olhos para calibrar';
            instruction.style.position = 'absolute';
            instruction.style.top = '20px';
            instruction.style.left = '50%';
            instruction.style.transform = 'translateX(-50%)';
            instruction.style.color = '#fff';
            instruction.style.fontSize = '18px';
            instruction.style.fontFamily = 'Inter, sans-serif';
            instruction.style.textAlign = 'center';

            const dot = document.createElement('div');
            dot.id = 'calibration-dot';
            dot.style.position = 'absolute';
            dot.style.width = '28px';
            dot.style.height = '28px';
            dot.style.borderRadius = '50%';
            dot.style.background = '#10b981';
            dot.style.boxShadow = '0 0 0 10px rgba(16,185,129,0.25)';
            dot.style.border = '2px solid #ffffff';
            dot.style.transition = 'transform 300ms ease';

            overlay.appendChild(instruction);
            overlay.appendChild(dot);
            document.body.appendChild(overlay);

            webgazer.clearData();
            webgazer.showVideo(true);
            webgazer.showFaceOverlay(false);
            webgazer.showFaceFeedbackBox(false);
            webgazer.showPredictionPoints(false);

            const w = window.innerWidth;
            const h = window.innerHeight;
            const mx = Math.floor(w * 0.1);
            const my = Math.floor(h * 0.1);
            const points = [
                { x: mx, y: my },
                { x: w - mx, y: my },
                { x: w - mx, y: h - my },
                { x: mx, y: h - my },
                { x: Math.floor(w / 2), y: Math.floor(h / 2) }
            ];

            const settleMs = 800;
            const sampleMs = 2000;
            const intervalMs = 33;

            const calibTargets = [];
            const calibPreds = [];

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                dot.style.transform = `translate(${p.x - 10}px, ${p.y - 10}px)`;
                await new Promise(r => setTimeout(r, settleMs));
                const samples = [];
                const started = Date.now();
                await new Promise(r => {
                    const t = setInterval(() => {
                        webgazer.recordScreenPosition(p.x, p.y, 'click');
                        const pred = webgazer.getCurrentPrediction && webgazer.getCurrentPrediction();
                        if (pred && typeof pred.x === 'number' && typeof pred.y === 'number') {
                            samples.push({ x: pred.x, y: pred.y });
                        }
                        if (Date.now() - started >= sampleMs) {
                            clearInterval(t);
                            r(null);
                        }
                    }, intervalMs);
                });
                const median = (arr, sel) => {
                    if (!arr.length) return sel==='x'?p.x:p.y;
                    const vals = arr.map(v=>sel==='x'?v.x:v.y).sort((a,b)=>a-b);
                    const mid = Math.floor(vals.length/2);
                    return vals.length%2?vals[mid]:(vals[mid-1]+vals[mid])/2;
                };
                const avgx = median(samples,'x');
                const avgy = median(samples,'y');
                calibTargets.push({ x: p.x, y: p.y });
                calibPreds.push({ x: avgx, y: avgy });
            }

            gazePoly = computePolyTransform(calibPreds, calibTargets);
            lastSmoothed = null;

            statusMessage.textContent = 'Calibração 1/2 concluída. Refinando no teclado...';

            const krect = keyboardGridContainer.getBoundingClientRect();
            keyboardGridContainer.style.display = 'block';
            const kpoints = [
                { x: Math.floor(krect.left + krect.width*0.2), y: Math.floor(krect.top + krect.height*0.33) },
                { x: Math.floor(krect.left + krect.width*0.5), y: Math.floor(krect.top + krect.height*0.33) },
                { x: Math.floor(krect.left + krect.width*0.8), y: Math.floor(krect.top + krect.height*0.33) },
                { x: Math.floor(krect.left + krect.width*0.3), y: Math.floor(krect.top + krect.height*0.7) },
                { x: Math.floor(krect.left + krect.width*0.7), y: Math.floor(krect.top + krect.height*0.7) }
            ];

            for (let i = 0; i < kpoints.length; i++) {
                const p = kpoints[i];
                dot.style.transform = `translate(${p.x - 10}px, ${p.y - 10}px)`;
                await new Promise(r => setTimeout(r, settleMs));
                const samples = [];
                const started = Date.now();
                await new Promise(r => {
                    const t = setInterval(() => {
                        webgazer.recordScreenPosition(p.x, p.y, 'click');
                        const pred = webgazer.getCurrentPrediction && webgazer.getCurrentPrediction();
                        if (pred && typeof pred.x === 'number' && typeof pred.y === 'number') {
                            samples.push({ x: pred.x, y: pred.y });
                        }
                        if (Date.now() - started >= sampleMs) {
                            clearInterval(t);
                            r(null);
                        }
                    }, intervalMs);
                });
                const median = (arr, sel) => {
                    if (!arr.length) return sel==='x'?p.x:p.y;
                    const vals = arr.map(v=>sel==='x'?v.x:v.y).sort((a,b)=>a-b);
                    const mid = Math.floor(vals.length/2);
                    return vals.length%2?vals[mid]:(vals[mid-1]+vals[mid])/2;
                };
                const avgx = median(samples,'x');
                const avgy = median(samples,'y');
                calibTargets.push({ x: p.x, y: p.y });
                calibPreds.push({ x: avgx, y: avgy });
            }

            gazePoly = computePolyTransform(calibPreds, calibTargets);

            document.body.removeChild(overlay);
            calibrating = false;
            isCalibrated = true;
            statusMessage.textContent = 'Calibração concluída. Digite com o olhar.';
            statusMessage.classList.remove('text-red-500');
            statusMessage.classList.add('text-green-500');
            calibrateBtn.textContent = 'Recalibrar Olhar';
            calibrateBtn.disabled = false;
            webgazer.showVideo(false);
            webgazer.showFaceOverlay(false);
            webgazer.showFaceFeedbackBox(false);
            webgazer.showPredictionPoints(false);
            textOutput.disabled = false;
            deleteBtn.disabled = false;
            clearBtn.disabled = false;
        }

        function computePolyTransform(src, dst) {
            const buildNormal = (samples, targetsComponent) => {
                const M = Array.from({length:6},()=>Array(6).fill(0));
                const V = Array(6).fill(0);
                const basis = (x,y) => [1, x, y, x*x, x*y, y*y];
                for (let i=0;i<samples.length;i++){
                    const x = samples[i].x, y = samples[i].y; const b = basis(x,y);
                    const t = targetsComponent(i);
                    for (let r=0;r<6;r++){
                        V[r] += b[r]*t;
                        for (let c=0;c<6;c++) M[r][c] += b[r]*b[c];
                    }
                }
                return {M,V};
            };
            const {M: Mx, V: Vx} = buildNormal(src, i=>dst[i].x);
            const {M: My, V: Vy} = buildNormal(src, i=>dst[i].y);
            const ax = gaussianSolve(Mx, Vx) || [0,1,0,0,0,0];
            const ay = gaussianSolve(My, Vy) || [0,0,1,0,0,0];
            return { ax, ay };
        }

        function gaussianSolve(A, b) {
            const n = 6;
            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let r = i + 1; r < n; r++) {
                    if (Math.abs(A[r][i]) > Math.abs(A[maxRow][i])) maxRow = r;
                }
                if (Math.abs(A[maxRow][i]) < 1e-8) return null;
                if (maxRow !== i) {
                    const tmp = A[i];
                    A[i] = A[maxRow];
                    A[maxRow] = tmp;
                    const tb = b[i];
                    b[i] = b[maxRow];
                    b[maxRow] = tb;
                }
                const pivot = A[i][i];
                for (let j = i; j < n; j++) A[i][j] /= pivot;
                b[i] /= pivot;
                for (let r = 0; r < n; r++) {
                    if (r === i) continue;
                    const f = A[r][i];
                    for (let j = i; j < n; j++) A[r][j] -= f * A[i][j];
                    b[r] -= f * b[i];
                }
            }
            return b;
        }
        
        // --- FUNÇÕES DE UTILITY PARA RECURSOS DO CLMTRACKR ---
        // Adicionando um pequeno polyfill/ajuste para compatibilidade do clmtrackr
        const audio = new Audio();
        if(audio.mozSetup) {
            // Correção para clmtrackr que falha a inicialização do áudio no Chrome
            // O clmtrackr não é estritamente necessário para áudio, mas previne falhas de init
        }

    </script>
</body>
</html>
        function updateCalibrationCursor(x, y) {
            const gazeDot = document.getElementById('gaze-dot');
            if (!gazeDot) return;
            const tx = Math.max(0, Math.min(window.innerWidth - 1, x));
            const ty = Math.max(0, Math.min(window.innerHeight - 1, y));
            gazeDot.style.transform = `translate(${tx - 10}px, ${ty - 10}px)`;
        }
