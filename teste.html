<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EyeSpeak üëÅÔ∏è - Comunicador Ocular</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            min-height: 100vh;
            background-color: #1f2937; /* Fundo Escuro para Reduzir Fadiga Ocular */
            color: #f3f4f6;
        }
        main {
            display: flex;
            gap: 24px;
        }
        /* Estilos do Teclado Principal */
        #keyboard-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 6px; /* Aumentar o espa√ßamento */
        }
        .key-button {
            padding: 1.25rem 0.5rem; /* Aumentar o tamanho para facilitar o olhar */
            text-align: center;
            font-size: 1.5rem; /* Fonte maior */
            font-weight: 500;
            background-color: #374151; /* Cor de fundo da tecla */
            color: #f3f4f6;
            border: 2px solid #4b5563;
            transition: all 0.1s;
            cursor: default;
            user-select: none;
            border-radius: 0.75rem;
        }
        /* Destaque para Sele√ß√£o */
        .highlighted {
            background-color: #3b82f6; /* Azul Prim√°rio */
            color: white;
            border-color: #2563eb;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
            transform: scale(1.03);
        }
        /* Destaque para Confirma√ß√£o */
        .selected {
            background-color: #10b981 !important; /* Verde de Sucesso */
            border-color: #059669 !important;
        }
        .progress-bar {
            height: 10px; /* Mais vis√≠vel */
            background-color: #f59e0b; /* Amarelo de Progresso */
            width: 0%;
            transition: width 0.05s linear;
            position: absolute;
            bottom: 0;
            left: 0;
            border-radius: 0 0 0.5rem 0.5rem;
        }
        .key-container {
            position: relative;
            overflow: hidden;
        }
        /* Cursor de Olhar (Gaze Dot) */
        #gaze-dot {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #f59e0b; /* Laranja/Amarelo */
            box-shadow: 0 0 0 6px rgba(245, 158, 11, 0.4);
            transform: translate(-100px,-100px);
            transition: none; /* Sem transi√ß√£o para rastreamento suave */
        }
        /* Webcam Feed Pequena e no Canto */
        #video-container {
            position: fixed;
            top: 24px;
            right: 24px;
            width: 280px;
            height: 210px;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
            border: 4px solid #3b82f6;
            z-index: 100;
        }
        #webcam-video, #webcam-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
    </style>
</head>
<body class="p-6 md:p-8">

    <div id="gaze-overlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 9998;"><div id="gaze-dot"></div></div>

    <header class="mb-8">
        <h1 class="text-4xl font-bold text-white">EyeSpeak üó£Ô∏è</h1>
        <p class="text-gray-400">Comunica√ß√£o Aumentativa por Rastreamento Ocular (WebGazer)</p>
    </header>

    <div id="video-container">
        <video id="webcam-video" autoplay playsinline></video>
        <canvas id="webcam-canvas" style="display:none;"></canvas>
    </div>

    <main class="flex flex-col gap-8">
        
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl">
            <h2 class="text-2xl font-semibold mb-3 text-gray-200">Sa√≠da de Texto</h2>
            <textarea id="text-output" aria-label="Sa√≠da de texto" rows="3" class="w-full text-2xl p-4 bg-gray-900 text-white rounded-lg focus:outline-none resize-none border-2 border-gray-700" placeholder="Olhe para a tela e calibre para come√ßar a digitar..."></textarea>
            
            <div class="flex justify-between items-center mt-4">
                <p id="status-message" role="status" aria-live="polite" class="text-lg text-yellow-400 font-medium">Aguardando rastreador ocular...</p>
                
                <div class="flex space-x-3">
                    <button id="delete-btn" class="flex items-center bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2m4-2v2m0 12v2"></path></svg>
                        Apagar
                    </button>
                    <button id="clear-btn" class="flex items-center bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        Limpar
                    </button>
                </div>
            </div>
            
            <div class="flex items-center justify-between mt-6 p-3 bg-gray-700 rounded-lg">
                <label for="dwell-slider" class="text-lg text-gray-300">
                    Tempo de Perman√™ncia (Dwell): <span id="dwell-value" class="font-bold text-white">1.5</span>s
                </label>
                <input id="dwell-slider" type="range" min="1" max="5" step="0.5" value="1.5" class="w-48">

                <button id="calibrate-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-150" disabled>
                    Iniciar Calibra√ß√£o (9 Pontos)
                </button>
            </div>
        </div>

        <div id="keyboard-grid-container" class="bg-gray-800 p-8 rounded-xl shadow-2xl flex-1">
            <h2 class="text-2xl font-semibold mb-6 text-gray-200">Teclado Virtual</h2>
            <div id="keyboard-grid" role="grid">
                </div>
        </div>

    </main>

    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>

    <script>
        // --- VARI√ÅVEIS GLOBAIS ---
        const video = document.getElementById('webcam-video');
        const statusMessage = document.getElementById('status-message');
        const textOutput = document.getElementById('text-output');
        const keyboardGrid = document.getElementById('keyboard-grid');
        const calibrateBtn = document.getElementById('calibrate-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const clearBtn = document.getElementById('clear-btn');
        
        let DWELL_TIME_SECONDS = 1.5;
        const SELECTION_INTERVAL_MS = 50; // Intervalo mais r√°pido para melhor feedback
        let currentSelectionKey = null;
        let selectionProgress = 0;
        let MAX_PROGRESS = DWELL_TIME_SECONDS * (1000 / SELECTION_INTERVAL_MS);
        const HYSTERESIS_MS = 150; // Tempo m√≠nimo para mudar de tecla (reduz jitter)
        let pendingKey = null;
        let pendingSince = 0;
        const SMOOTH_ALPHA = 0.2; // Fator de Suaviza√ß√£o (menor = mais suave)
        let lastSmoothedGaze = null;
        
        const keys = [
            'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
            'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'BACK',
            'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', 'ENTER',
            'SHIFT', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', 'SPACE', '?', '!', '@', '#', '$', '%', '&', 'CLEAR'
        ];

        // --- FUN√á√ïES DE SETUP ---

        /**
         * Cria e insere os bot√µes do teclado no DOM.
         */
        function createKeyboard() {
            keyboardGrid.innerHTML = ''; // Limpar antes de criar
            keys.forEach(key => {
                const container = document.createElement('div');
                container.className = 'key-container';
                container.setAttribute('data-key', key);
                
                // Ajustes de span/tamanho para chaves especiais
                if (key === 'SPACE') container.style.gridColumn = 'span 4';
                if (key === 'SHIFT') container.style.gridColumn = 'span 2';
                if (key === 'BACK' || key === 'ENTER' || key === 'CLEAR') container.style.gridColumn = 'span 2';
                
                const button = document.createElement('button');
                button.className = 'key-button w-full h-full';
                let label = key;
                if (key === 'SPACE') label = 'ESPA√áO';
                if (key === 'BACK') label = 'APAGAR';
                if (key === 'CLEAR') label = 'LIMPAR TUDO';
                if (key === 'ENTER') label = 'ENVIAR';
                if (key === 'SHIFT') label = 'MAI√öSCULAS';

                button.textContent = label;
                button.id = `key-${key.replace(/[^a-zA-Z0-9]/g, '_')}`;
                button.setAttribute('role','button');
                button.setAttribute('aria-label', label);

                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                
                container.appendChild(button);
                container.appendChild(progressBar);
                keyboardGrid.appendChild(container);
            });
        }
        
        // --- FUN√á√ïES DE RASTREAMENTO E SELE√á√ÉO ---

        /**
         * Processa o ponto de olhar na tela (x, y) e tenta destacar uma chave.
         */
        function processGazePoint(x, y) {
            // 1. Suaviza√ß√£o (Kalman j√° est√° aplicado no webgazer, mas a suaviza√ß√£o manual ajuda)
            if (!lastSmoothedGaze) {
                lastSmoothedGaze = { x: x, y: y };
            } else {
                x = SMOOTH_ALPHA * x + (1 - SMOOTH_ALPHA) * lastSmoothedGaze.x;
                y = SMOOTH_ALPHA * y + (1 - SMOOTH_ALPHA) * lastSmoothedGaze.y;
                lastSmoothedGaze = { x: x, y: y };
            }

            // Atualiza o cursor visual
            const gazeDot = document.getElementById('gaze-dot');
            gazeDot.style.transform = `translate(${x - 7.5}px, ${y - 7.5}px)`;
            
            // 2. Encontrar a Chave de Destino
            const targetElement = document.elementFromPoint(x, y);
            const targetKeyContainer = targetElement && targetElement.closest('.key-container');

            if (targetKeyContainer) {
                // A) L√≥gica de Hist√©rese (Key Switching)
                if (currentSelectionKey !== targetKeyContainer) {
                    if (pendingKey !== targetKeyContainer) {
                        // Novo candidato, reinicia contagem de pending
                        pendingKey = targetKeyContainer;
                        pendingSince = Date.now();
                        resetSelection(); // Resetar visualmente
                    } else if (Date.now() - pendingSince >= HYSTERESIS_MS) {
                        // Candidato est√° est√°vel o suficiente, destacar e iniciar dwell
                        currentSelectionKey = targetKeyContainer;
                        selectionProgress = 0;
                        pendingKey = null;
                        pendingSince = 0;
                    }
                }
                
                if (currentSelectionKey === targetKeyContainer) {
                    highlightKey(currentSelectionKey);
                }

            } else {
                // N√£o est√° olhando para nenhuma chave v√°lida
                resetSelection();
            }
        }
        
        /**
         * Destaca uma chave visualmente.
         */
        function highlightKey(keyContainer) {
            const button = keyContainer.querySelector('.key-button');
            if (!button.classList.contains('highlighted')) {
                // Remove destaque de todas as outras chaves
                document.querySelectorAll('.key-button').forEach(btn => btn.classList.remove('highlighted', 'selected'));
                // Aplica destaque na atual
                button.classList.add('highlighted');
            }
        }

        /**
         * Reseta o estado de sele√ß√£o.
         */
        function resetSelection() {
            if (currentSelectionKey) {
                // Remove destaque e zera a barra de progresso da chave anterior
                currentSelectionKey.querySelector('.key-button').classList.remove('highlighted', 'selected');
                currentSelectionKey.querySelector('.progress-bar').style.width = '0%';
            }
            currentSelectionKey = null;
            selectionProgress = 0;
        }

        /**
         * Loop principal do Dwell Time.
         */
        function selectionLoop() {
            if (currentSelectionKey && !window.calibrating) {
                selectionProgress++;
                
                const keyContainer = currentSelectionKey;
                const keyChar = keyContainer.getAttribute('data-key');
                const button = keyContainer.querySelector('.key-button');
                const progressBar = keyContainer.querySelector('.progress-bar');

                // Atualiza o progresso visual
                const percentage = (selectionProgress / MAX_PROGRESS) * 100;
                progressBar.style.width = `${percentage}%`;

                if (selectionProgress >= MAX_PROGRESS) {
                    // SELE√á√ÉO CONCLU√çDA!
                    processSelection(keyChar);

                    // Efeito visual de sele√ß√£o
                    button.classList.add('selected');
                    setTimeout(() => {
                        button.classList.remove('selected');
                    }, 150);

                    if (window.selectionBeep) window.selectionBeep();

                    // Reinicia o dwell para a chave atual (permite sele√ß√£o cont√≠nua)
                    selectionProgress = 0;
                }
            }
        }
        
        /**
         * Executa a a√ß√£o da chave selecionada.
         */
        function processSelection(keyChar) {
            let currentText = textOutput.value;
            switch(keyChar) {
                case 'SPACE':
                    textOutput.value = currentText + ' ';
                    break;
                case 'BACK':
                    textOutput.value = currentText.slice(0, -1);
                    break;
                case 'CLEAR':
                    textOutput.value = '';
                    break;
                case 'ENTER':
                    // A√ß√£o de envio/nova linha (pode ser ajustada)
                    textOutput.value = currentText + '\n';
                    break;
                case 'SHIFT':
                    // Implementa√ß√£o de SHIFT mais complexa (alternar o teclado), por enquanto ignora.
                    break;
                default:
                    // Caracter normal
                    textOutput.value = currentText + keyChar;
                    break;
            }
        }
        
        // --- CALIBRA√á√ÉO 9 PONTOS (WebGazer) ---

        /**
         * Inicia o processo de calibra√ß√£o de 9 pontos do WebGazer.
         * Esta √© a calibra√ß√£o padr√£o e mais robusta do WebGazer, garantindo um bom mapeamento polinomial.
         */
        async function startGazeCalibration() {
            if (!window.webgazer) return;
            window.calibrating = true;
            resetSelection();
            calibrateBtn.disabled = true;
            calibrateBtn.textContent = 'Calibrando... Olhe para os pontos!';
            
            // Requerimentos: Calibra√ß√£o de 9 pontos (melhor precis√£o)
            const calibPoints = [0, 1, 2, 3, 4, 5, 6, 7, 8];
            let currentPointIndex = 0;

            const overlay = createCalibrationOverlay();
            document.body.appendChild(overlay);
            const dot = document.getElementById('calibration-dot');
            const instruction = document.getElementById('calib-instruction');

            webgazer.clearData();
            webgazer.showVideo(false);
            webgazer.showPredictionPoints(true); // Exibir pontos para feedback
            
            const points = [
                { x: 0.1, y: 0.1 }, { x: 0.5, y: 0.1 }, { x: 0.9, y: 0.1 },
                { x: 0.1, y: 0.5 }, { x: 0.5, y: 0.5 }, { x: 0.9, y: 0.5 },
                { x: 0.1, y: 0.9 }, { x: 0.5, y: 0.9 }, { x: 0.9, y: 0.9 }
            ];
            
            const CALIB_DWELL_MS = 1500; // Tempo de perman√™ncia em cada ponto

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const screenX = window.innerWidth * p.x;
                const screenY = window.innerHeight * p.y;
                
                instruction.textContent = `Ponto ${i + 1} de ${points.length}. Mantenha o olhar fixo.`;
                dot.style.transform = `translate(${screenX - 14}px, ${screenY - 14}px)`;
                
                // Espera um momento para o usu√°rio fixar o olhar
                await new Promise(r => setTimeout(r, 500)); 

                // Simula o clique e coleta de dados para calibra√ß√£o
                for (let j = 0; j < 30; j++) { // 30 amostras em 1.5s
                    webgazer.recordScreenPosition(screenX, screenY, 'click');
                    await new Promise(r => setTimeout(r, 50));
                }
            }

            webgazer.setGazeListener(null); // Pausa o listener
            webgazer.util.getPolynomialTransform(2).then(transform => {
                webgazer.screenCalibration = transform; // Armazena a transforma√ß√£o
                webgazer.setGazeListener(function(data) {
                    if (data) processGazePoint(data.x, data.y);
                });

                document.body.removeChild(overlay);
                window.calibrating = false;
                calibrateBtn.textContent = 'Recalibrar Olhar';
                calibrateBtn.disabled = false;
                statusMessage.textContent = 'Calibra√ß√£o conclu√≠da! Digite com o olhar.';
                statusMessage.classList.remove('text-yellow-400', 'text-red-500');
                statusMessage.classList.add('text-green-500');

                // Habilita as fun√ß√µes de texto
                textOutput.disabled = false;
                deleteBtn.disabled = false;
                clearBtn.disabled = false;
            }).catch(e => {
                console.error("Erro na Calibra√ß√£o:", e);
                document.body.removeChild(overlay);
                window.calibrating = false;
                calibrateBtn.textContent = 'Falha na Calibra√ß√£o! Tentar Novamente.';
                calibrateBtn.disabled = false;
                statusMessage.textContent = 'ERRO: Falha ao gerar transforma√ß√£o de olhar. Tente novamente.';
                statusMessage.classList.add('text-red-500');
            });
        }
        
        function createCalibrationOverlay() {
            const overlay = document.createElement('div');
            overlay.id = 'calibration-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.85); 
                z-index: 9999; display: flex; align-items: center; justify-content: center; pointer-events: none;
            `;
            const instruction = document.createElement('div');
            instruction.id = 'calib-instruction';
            instruction.textContent = 'Calibra√ß√£o: Siga o ponto com os olhos.';
            instruction.style.cssText = `
                position: absolute; top: 10vh; left: 50%; transform: translateX(-50%); color: #fff; 
                font-size: 24px; font-weight: 500; text-align: center;
            `;
            const dot = document.createElement('div');
            dot.id = 'calibration-dot';
            dot.style.cssText = `
                position: absolute; width: 28px; height: 28px; border-radius: 50%; background: #10b981; 
                box-shadow: 0 0 0 10px rgba(16,185,129,0.25); border: 4px solid #ffffff; transition: transform 300ms ease;
            `;
            overlay.appendChild(instruction);
            overlay.appendChild(dot);
            return overlay;
        }

        // --- INICIALIZA√á√ÉO E EVENT LISTENERS ---

        window.onload = function() {
            createKeyboard();
            
            calibrateBtn.addEventListener('click', startGazeCalibration);
            deleteBtn.addEventListener('click', () => processSelection('BACK'));
            clearBtn.addEventListener('click', () => processSelection('CLEAR'));

            const dwellSlider = document.getElementById('dwell-slider');
            const dwellValue = document.getElementById('dwell-value');
            dwellSlider.addEventListener('input', () => {
                DWELL_TIME_SECONDS = parseFloat(dwellSlider.value);
                dwellValue.textContent = DWELL_TIME_SECONDS.toFixed(1);
                MAX_PROGRESS = DWELL_TIME_SECONDS * (1000 / SELECTION_INTERVAL_MS);
                selectionProgress = 0; // Resetar para aplicar o novo tempo
            });

            // Configura o WebGazer
            webgazer.applyKalmanFilter(true); // Uso do filtro Kalman do WebGazer
            webgazer.setRegression('ridge');
            webgazer.setTracker('TFFacemesh');
            webgazer.showVideo(true); // Exibir o v√≠deo no container fixo
            webgazer.showFaceOverlay(false);
            webgazer.showFaceFeedbackBox(false);
            webgazer.showPredictionPoints(false);
            
            // Inicia o WebGazer
            webgazer.begin().then(() => {
                statusMessage.textContent = 'Rastreamento ocular pronto. Calibre o olhar para come√ßar.';
                calibrateBtn.disabled = false;

                // Configura o listener principal
                webgazer.setGazeListener(function(data, elapsedTime) {
                    if (data && typeof data.x === 'number' && typeof data.y === 'number' && !window.calibrating) {
                        processGazePoint(data.x, data.y);
                    }
                });

                // Inicializa o som de feedback
                const AC = window.AudioContext || window.webkitAudioContext;
                if (AC) {
                    const ctx = new AC();
                    window.selectionBeep = () => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = 660; // Frequ√™ncia um pouco mais baixa
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        gain.gain.setValueAtTime(0.001, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
                        osc.start();
                        osc.stop(ctx.currentTime + 0.1);
                    };
                }

            }).catch(e => {
                statusMessage.textContent = 'ERRO: N√£o foi poss√≠vel iniciar o rastreamento ocular. Verifique as permiss√µes da c√¢mera.';
                statusMessage.classList.remove('text-yellow-400');
                statusMessage.classList.add('text-red-500');
            });

            // Inicia o loop de sele√ß√£o por intervalo
            setInterval(selectionLoop, SELECTION_INTERVAL_MS);
        };
    </script>
</body>
</html>